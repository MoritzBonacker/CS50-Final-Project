We knew from the beginning that our idea of creating a donation platform for young people had to be a mobile app. Donations should become part of everyday life and young people interact constantly with their mobile devices. Because of the large audience and the great support for developers, we chose to develop our app for iOS. We all were excited about the opportunity to gain insights into the completely new world of app development and to learn a further programming language. We implemented our project in Swift as we wanted to use a modern and strongly object-oriented language, building up on our good experience with Python. We also took advantage of the amazing documentation and tutorials for programming in swift.
 
Storing user information as well as information about charities requires some kind of database structure. The first major decision was hence to choose a database for our app. Under consideration were among others SQL, Cloudkit and Firebase. Even though we had already worked with SQL before, we decided to use Firebase for several reasons. Data in Firebase is stored in a tree structure. According to our research, this is the state-of-the-art way to store data and is faster and more reliable than storing data in tables. Moreover, Firebase provides many prebuilt functions like authenticating users via various authentication methods and communicates directly with the app. It is free to use and not tied to any particular platform. Overall, these advantages convinced us to choose this database provider. As we chose Firebase as our database provider, we had to use CocoaPods for our project. CocoaPods provide the additional advantage of keeping all of our libraries automatically up to date.
 
Firebase stores user data separate from data which is written to the database. User data is automatically inserted so we did not have to deal with it. Our own data is stored under two main branches: “Charities” and “user”. The “Charities”-branch contains all information about charities displayed in our app. This includes the following information: Name, description, link to homepage, name of image file, rating and category. The description of charities was retrieved from Wikipedia and/or Charitynavigator  (https://www.charitynavigator.org/). The rating was also based on ratings displayed at Charitynavigator. Pictures were downloaded from various sources but mainly from the webpage of the respective charity. All of the information was added manually to the database and pictures were uploaded to the assets of our Xcode project. We also defined security rules in Firebase allowing users only to read their own personal data as well as public data about charities. Users can write to their own data but neither to other users’ personal data or public data.
 
Our project in Xcode consists of one main storyboard as well as several view controllers. Speaking in the MVC model, the storyboard is the view, the view controllers are the controller, and Firebase is the model of our application. The LoginViewController manages the login functionality. If the user enters login credentials, these credentials are transferred to Firebase (via the “signIn”-method) which checks if the credentials are valid. Dependent on the outcome of this test, the user can access the next page or sees a user alert displaying the error message. We took advantage of the pre-built functionalities provided by Firebase, thereby minimizing the lines of code needed. The same mechanism is applied to the register functionality, which is connected to the RegisterViewController. If the user is logged in or has registered, he can proceed to the category overview. Categories are predefined in the array “categories” and displayed in the table view. This CategoryViewController first determines the number of cells needed and then changes the content of each cell according to the respective category. The user can then choose a category. The user’s choice is pushed to the next view controller in order to load the correct charities into the view. We implemented the TableView following best practices from tutorials, scaling the table flexibly independent of the concrete data input.
 
The CharityViewController first retrieves data for all charities which belong to the category chosen from Firebase. This data is stored in a dictionary of type <String, AnyObject>. All keys of this dictionary (which are the charities’ names) are stored as a separate array. Afterwards the controller changes the data in the CharityView template to the data of the first charity retrieved from Firebase. The controller also contains a SwipeGestureRecognizer which recognizes if the user swiped right or left. The current position in the Charity View is documented through a counter variable. When the user swipes, the counter variable is updated. In order to update the CharityView, the controller accesses the retrieved dictionary by referencing a particular charity through the counter variable. More detail on this can be found in the code.
 
If the user clicks the donate button, he can choose between three different amounts to donate. If he decides to donate, the name of the selected charity as well as the amount and an automatically generated timestamp are inserted into the database. The user can then return to the category page. The user also has the option to access a personal profile page. Here he can find his personal transaction history including the name of the charity donated to as well as the amount. This data is retrieved by querying our database. We defined a struct “Transaction” which contains as its property the values needed thereby reaching a clean and efficient design. The controller also provides the date and time of the most recent donation by accessing the first element of the array containing all transactions. Transactions are defined as a separate class having the properties name, amount and date.
For designing the user interface in the Main.storyboard we followed best practices we learned from online tutorials (cited in code). One of the main difficulties lied in setting constraints for all elements in order for the app to work across devices (we developed for iPhone 6 and iPhone X and added constraints to make it look the same on other iPhones). We implemented the segues by dragging and holding controls instead of doing so with code due to the easier and better handling. The other elements we used were mainly UIImageViews, Labels and Buttons. For the charity ViewController we furthermore implemented a scroll view for a better user experience. For implementing the donation history a TableView was the obvious choice as this enabled us to display a theoretically unlimited amount of rows with donation transactions and have the table dynamically size. To navigate back to the previous ViewController we made use of a Navigation Controller as this enabled fluent user navigation. When navigation to multiple ViewControllers was needed we either used multiple buttons or when not possible (for example in the category view as there was a full screen TableView) we made use of “bar button items” (to get to the profile). To stylize the buttons we decided to code a function that could be called by all ViewControllers in order to have uniformly stylized buttons and only define the style once.
We incredibly enjoyed the experience of developing our own iOS app. We are overwhelmed by the success we had developing the app and all of the learnings during our projects. We are thinking about further developing our app and will work on the following next steps to improve our app: 
1. Importing further charity data by using an external API (e.g. the one from “Charitynavigator”)
2. Improving the user experience by including further interaction (e.g. more interactive swipe gesture) and possibilities to communicate through the app (e.g. link with Facebook profile / messaging functionality)
3. Adding constraints to our user interface to ensure a proper design on iPhone generations
4. Including an actual payment system rather than a fictional one
 
Looking back on the project, we also now know some things we would do differently in the future:
 
1. Choose a different data structure. Our data structure is not flat enough and has too many elements on a high hierarchical level.
2. Implement the project using several storyboards to allow for better collaboration on the user interface
 
We enjoyed the final project a lot and thank all of CS50’s staff for the great support throughout the semester!
